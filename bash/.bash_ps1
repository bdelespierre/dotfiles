#!/bin/bash

# Special prompt variable characters:
# \d   The date, in "Weekday Month Date" format (e.g., "Tue May 26").
# \h   The hostname, up to the first . (e.g. deckard)
# \H   The hostname. (e.g. deckard.SS64.com)
# \j   The number of jobs currently managed by the shell.
# \l   The basename of the shell's terminal device name.
# \s   The name of the shell, the basename of $0 (the portion following the final slash).
# \t   The time, in 24-hour HH:MM:SS format.
# \T   The time, in 12-hour HH:MM:SS format.
# \@   The time, in 12-hour am/pm format.
# \u   The username of the current user.
# \v   The version of Bash (e.g., 2.00)
# \V   The release of Bash, version + patchlevel (e.g., 2.00.0)
# \w   The current working directory.
# \W   The basename of $PWD.
# \!   The history number of this command.
# \#   The command number of this command.
# \$   If you are not root, inserts a "$"; if you are root, you get a "#"  (root uid = 0)

# get bash colors and styles here: http://misc.flogisoft.com/bash/tip_colors_and_formatting
# get PS1 variables here: http://ss64.com/bash/syntax-prompt.html
C_RESET='\[\e[0m\]'
C_BLINK='\[\e[5m\]'
C_BOLD='\[\e[1m\]'
C_BLACK='\[\e[30m\]'
C_RED='\[\e[31m\]'
C_GREEN='\[\e[32m\]'
C_YELLOW='\[\e[33m\]'
C_BLUE='\[\e[34m\]'
C_MAGENTA='\[\e[35m\]'
C_CYAN='\[\e[36m\]'
C_LIGHT_GRAY='\[\e[37m\]'
C_DEFAULT='\[\e[39m\]'
C_DARK_GRAY='\[\e[90m\]'
C_LIGHT_RED='\[\e[91m\]'
C_LIGHT_GREEN='\[\e[92m\]'
C_LIGHT_YELLOW='\[\e[93m\]'
C_LIGHT_BLUE='\[\e[94m\]'
C_LIGHT_MAGENTA='\[\e[95m\]'
C_LIGHT_CYAN='\[\e[96m\]'
C_WHITE='\[\e[97m\]'

C_PRIMARY="${C_MAGENTA}"
C_SECONDARY="${C_YELLOW}"
C_MUTED="${C_DARK_GRAY}"
C_OK="${C_GREEN}"
C_NOK="${C_RED}"

function __ps1_exit_status #(time, exit_status)
{
    if [[ "${PS1_TIMER}" == "off" ]]; then
        return 0
    fi

    if [[ 0 == "$2" || 130 == "$2" ]]; then
        local COLOR=$C_OK
    else
        local COLOR=$C_NOK
    fi

    echo "${C_MUTED}time:${COLOR}${1:-0}s${C_RESET}"
}

function __ps1_git_branch
{
    if [[ "${PS1_GIT}" == "off" ]]; then
        return 0
    fi

    local BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)

    if [[ -z "${BRANCH}" ]]; then
        return 0
    fi

    if git diff --exit-code >/dev/null 2>&1; then
        local COLOR=$C_OK
    else
        local COLOR=$C_NOK
    fi

    local CHA_REGEX="s/ [0-9]+ files? changed,//"
    local INS_REGEX="s/ ([0-9]+) insertions?\(\+\),?/\x1B[32m+\1\x1B[0m/"
    local DEL_REGEX="s/ ([0-9]+) deletions?\(-\),?/\x1B[31m-\1\x1B[0m/"

    echo -n "${C_MUTED}git:${COLOR}${BRANCH}${C_RESET}"
    git diff --shortstat | sed -r "${CHA_REGEX}; ${INS_REGEX}; ${DEL_REGEX}"
}

function __ps1_jobs
{
    if [[ "${PS1_JOBS}" == "off" ]]; then
        return 0
    fi

    local STOPPED_COUNT=$(jobs -sp | wc -l)
    local RUNNING_COUNT=$(jobs -rp | wc -l)

    # if there are too many jobs to display, display a count instead
    if (( STOPPED_COUNT + RUNNING_COUNT > 3 )); then
        echo "${C_MUTED}jobs:${C_OK}${RUNNING_COUNT}${C_MUTED}/${C_SECONDARY}${STOPPED_COUNT}${C_RESET}"
        return 0
    fi

    local RUNNING=$(jobs -r | awk '{print $1 $3}' | xargs echo)
    local STOPPED=$(jobs -s | awk '{print $1 $3}' | xargs echo)

    if [[ ! -z "$RUNNING" ]]; then
        echo "${C_OK}${RUNNING}${C_RESET}"
    fi

    if [[ ! -z "$STOPPED" ]]; then
        echo "${C_SECONDARY}${STOPPED}${C_RESET}"
    fi
}

function __ps1_prompt #(time, exit_status)
{
    local LEFT=$(echo \
        "${C_SECONDARY}\u${C_MUTED}@${C_BOLD}${C_SECONDARY}\h${C_RESET}" \
        "${C_PRIMARY}\\t${C_RESET}" \
        "${C_MUTED}\\s#${C_MUTED}\\l!${C_SECONDARY}\\!${C_RESET}" \
        "${C_PRIMARY}\w${C_RESET}" \
    )

    local RIGHT=$(echo \
        $(__ps1_git_branch) \
        $(__ps1_jobs) \
        $(__ps1_exit_status $@) \
    )

    if [[ "${PS1_RIGHT}" == "off" ]]; then
        PS1=$(printf "%s %s \\\$ " "${LEFT}" "${RIGHT}")
        return 0
    fi

    # remove all formatting from $RIGHT
    local RIGHT_TEXT=$(echo $RIGHT | sed -e 's/\\\[\\e\[[0-9;]*[mGKHF]\\\]//g; s/\x1b\[[0-9;]*[mGKHF]//g')

    # determine the lenght of the horizontal padding
    local PAD=$(($COLUMNS - ${#RIGHT_TEXT}))

    echo # newline (does not appear after clear)
    PS1=$(printf "%${PAD}s%s\r%s\n${C_MUTED}\\\$${C_RESET} " " " "${RIGHT}" "${LEFT}")
}

function __ps1_timer_start
{
    PROMPT_TIMER=${PROMPT_TIMER:-$SECONDS}
}

function __ps1_timer_stop
{
    __ps1_prompt $(($SECONDS - $PROMPT_TIMER)) $?
    unset PROMPT_TIMER
}

if [[ "${PS1_TIMER}" != "off" ]]; then
    trap '__ps1_timer_start' DEBUG
    PROMPT_COMMAND=__ps1_timer_stop
else
    PROMPT_COMMAND=__ps1_prompt
fi
