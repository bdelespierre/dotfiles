#!/bin/bash
#
#  An elegant, convenient PS1 written ~almost~ entirely in Bash.
#  Relies on the following commands: git, sed.
#
#  ----------------------------------------------------------------------------
#  USAGE
#  ----------------------------------------------------------------------------
#
#  $ source .bash_ps1
#
#
#  ----------------------------------------------------------------------------
#  CONFIGURATION VARIABLES
#  ----------------------------------------------------------------------------
#
#  PS1_USER     string     Set to force username   (default \u)
#  PS1_HOST     string     Set to force hostname   (default \h)
#  PS1_SHELL    string     Set to force shell      (default \s)
#  PS1_TERM     string     Set to force terminal   (default \l)
#  PS1_RIGHT    boolean    Enable right side       (default true)
#  PS1_GIT      boolean    Enable git status       (default true)
#  PS1_JOBS     boolean    Enable jobs summary     (default true)
#  PS1_TIMER    boolean    Enable stopwatch        (default true)
#
#
#  ----------------------------------------------------------------------------
#  SPECIAL PROMPT VARIABLE CHARACTERS
#  ----------------------------------------------------------------------------
#
#  \d   The date, in "Weekday Month Date" format (e.g., "Tue May 26").
#  \h   The hostname, up to the first . (e.g. deckard)
#  \H   The hostname. (e.g. deckard.SS64.com)
#  \j   The number of jobs currently managed by the shell.
#  \l   The basename of the shell's terminal device name.
#  \s   The name of the shell, the basename of $0 (the portion following the final slash).
#  \t   The time, in 24-hour HH:MM:SS format.
#  \T   The time, in 12-hour HH:MM:SS format.
#  \@   The time, in 12-hour am/pm format.
#  \u   The username of the current user.
#  \v   The version of Bash (e.g., 2.00)
#  \V   The release of Bash, version + patchlevel (e.g., 2.00.0)
#  \w   The current working directory.
#  \W   The basename of $PWD.
#  \!   The history number of this command.
#  \#   The command number of this command.
#  \$   If you are not root, inserts a "$"; if you are root, you get a "#"  (root uid = 0)
#
#
#  ----------------------------------------------------------------------------
#  LINKS/CREDITS
#  ----------------------------------------------------------------------------
#
#  See: http://misc.flogisoft.com/bash/tip_colors_and_formatting
#  See: http://ss64.com/bash/syntax-prompt.html
#  See: https://gist.github.com/bingzhangdai/dd4e283a14290c079a76c4ba17f19d69
#  See: https://github.com/dylanaraps/pure-bash-bible
#  See: https://github.com/dylanaraps/pure-sh-bible
#
#
C_RESET='\[\e[0m\]';       C_BLINK='\[\e[5m\]';          C_BOLD='\[\e[1m\]';         C_BLACK='\[\e[30m\]'
C_RED='\[\e[31m\]';        C_GREEN='\[\e[32m\]';         C_YELLOW='\[\e[33m\]';      C_BLUE='\[\e[34m\]'
C_MAGENTA='\[\e[35m\]';    C_CYAN='\[\e[36m\]';          C_LIGHT_GRAY='\[\e[37m\]';  C_DEFAULT='\[\e[39m\]'
C_DARK_GRAY='\[\e[90m\]';  C_LIGHT_RED='\[\e[91m\]';     C_LIGHT_GREEN='\[\e[92m\]'; C_LIGHT_YELLOW='\[\e[93m\]'
C_LIGHT_BLUE='\[\e[94m\]'; C_LIGHT_MAGENTA='\[\e[95m\]'; C_LIGHT_CYAN='\[\e[96m\]';  C_WHITE='\[\e[97m\]'

__fast_git_branch() {
    local _head_file _head _dir="$PWD"

    while [[ -n "$_dir" ]]; do
        _head_file="$_dir/.git/HEAD"
        if [[ -f "$_dir/.git" ]]; then
            read -r _head_file < "$_dir/.git" && _head_file="$_dir/${_head_file#gitdir: }/HEAD"
        fi
        [[ -e "$_head_file" ]] && break
        _dir="${_dir%/*}"
    done

    if [[ -e "$_head_file" ]]; then
        read -r _head < "$_head_file" || return
        case "$_head" in
            ref:*) printf "${_head#ref: refs/heads/}" ;;
            "") ;;
            # HEAD detached
            *) printf "${_head:0:9}" ;;
        esac
        return 0
    fi

    return 1
}

__ps1_git() {
    # $1: (out) The function output

    local branch=$(__fast_git_branch)
    local -n output="$1"; output=""

    if [[ -z "${branch}" ]]; then
        return 0
    fi

    local prev="" ins="" del=""
    for n in $(git diff --shortstat | tr ',' ' '); do
        [[ "$n" == 'insertions(+)' || "$n" == 'insertion(+)' ]] && ins="$prev"
        [[ "$n" == 'deletions(-)'  || "$n" == 'deletion(-)'  ]] && del="$prev"
        prev="$n"
    done

    local color="${C_GREEN}" diff=""
    if [[ ! -z "$ins" || ! -z "$del" ]]; then
        color="${C_RED}"
        [[ ! -z "$ins" ]] && diff="${C_DARK_GRAY}/${C_RESET}${C_GREEN}+${ins}${C_RESET}"
        [[ ! -z "$ins" &&  ! -z "$del" ]] && diff+="${C_DARK_GRAY}/${C_RESET}"
        [[ ! -z "$del" ]] && diff+="${C_RED}-${del}${C_RESET}"
    fi

    output="${C_DARK_GRAY}git:${C_RESET}${color}${branch}${C_RESET}${diff}"
}

__ps1_jobs() {
    # $1: The result of 'jobs' command
    # $2: (out) The function output

    local color
    local -n output="$2"; output=""

    while IFS="\n" read -r -a job; do
        IFS=" " set -- $job
        [[ -z $3 ]] && continue
        [[ "$2" == "Running" ]] && color="$C_GREEN" || color="$C_YELLOW"
        [[ ! -z "$output" ]] && output+=" "
        output+="${C_DARK_GRAY}$1${color}$3${C_RESET}"
    done <<< "$1"
}

__ps1_timer() {
    # $1: The elapsed time since the last command (see __ps1_start_timer)
    # $2: The exit code of the last command ($?)
    # $3: (out) The function output

    local color
    local -n output="$3"; output=""
    [[ 0 == "$2" || 130 == "$2" ]] && color="$C_GREEN" || color="$C_RED"
    output="${C_DARK_GRAY}time:${color}${1:-0}s${C_RESET}"
}

__ps1_prompt() {
    # $1: The result of 'jobs' command (for parsing by __ps1_jobs)
    # $2: The exit code of the last command ($?)

    # newline (does not appear after clear)
    echo

    # user@hostname
    left="${C_GREEN}${PS1_USER:-\u}${C_DARK_GRAY}@${C_GREEN}${PS1_HOST:-\h}${C_RESET} "

    # time h:i:s
    left+="${C_MAGENTA}\\t${C_RESET} "

    # shell#term!cmd
    left+="${C_DARK_GRAY}${PS1_SHELL:-\s}#${C_DARK_GRAY}${PS1_TERM:-\l}!${C_MAGENTA}\\!${C_RESET} "

    # pwd
    left+="${C_YELLOW}\w${C_RESET}"

    # left-side is built!
    PS1="$left\n${C_DARK_GRAY}\\\$${C_RESET} "

    if [[ "$PS1_RIGHT" == false ]]; then
        return 0
    fi

    [[ "$PS1_GIT" != false ]] && __ps1_git git_output
    [[ "$PS1_JOBS" != false ]] && __ps1_jobs "$2" jobs_output
    [[ "$PS1_TIMER" != false ]] && __ps1_timer $(($SECONDS - $PROMPT_TIMER)) "$1" timer_output

    local right="$timer_output"
    [[ ! -z "$jobs_output" ]] && right="$jobs_output $right"
    [[ ! -z "$git_output" ]] && right="$git_output $right"

    # remove all formatting from $right
    local right_text=$(echo "$right" | sed -e 's/\\\[\\e\[[0-9;]*[mGKHF]\\\]//g')

    # determine the lenght of the horizontal padding
    local pad=$(($COLUMNS - ${#right_text}))

    # print right-side, then return, then print left
    PS1=$(printf "%${pad}s%s\r%s" " " "$right" "$PS1")

    unset PROMPT_TIMER
}

__ps1_start_timer() {
    PROMPT_TIMER=${PROMPT_TIMER:-$SECONDS}
}

trap '__ps1_start_timer' DEBUG
PROMPT_COMMAND='__ps1_prompt "$?" "$(jobs)"'
