#!/bin/bash
#
#  An elegant, convenient PS1 written ~almost~ entirely in Bash.
#
#  ----------------------------------------------------------------------------
#  USAGE
#  ----------------------------------------------------------------------------
#  $ source .bash_ps1
#

#  ----------------------------------------------------------------------------
#  CONFIGURATION VARIABLES
#  ----------------------------------------------------------------------------
#  PS1_USER   Set to force username      (default:"\u")
#  PS1_HOST   Set to force hostname      (default:"\h")
#  PS1_TTY    Set to force the TTY name  (default: "auto")
#  PS1_SHELL  Set to force shell         (default:"\s")
#  PS1_LEFT   Modules on the left side   (default:"user_host" "time" "tty_term_histnum" "pwd")
#  PS1_RIGHT  Modules on the right side  (default:"jobs" "git" "timer")
#

#  ----------------------------------------------------------------------------
#  SPECIAL PROMPT VARIABLE CHARACTERS
#  ----------------------------------------------------------------------------
#  \d   The date, in "Weekday Month Date" format (e.g., "Tue May 26").
#  \h   The hostname, up to the first . (e.g. deckard)
#  \H   The hostname. (e.g. deckard.SS64.com)
#  \j   The number of jobs currently managed by the shell.
#  \l   The basename of the shell's terminal device name.
#  \s   The name of the shell, the basename of $0 (the portion following the final slash).
#  \t   The time, in 24-hour HH:MM:SS format.
#  \T   The time, in 12-hour HH:MM:SS format.
#  \@   The time, in 12-hour am/pm format.
#  \u   The username of the current user.
#  \v   The version of Bash (e.g., 2.00)
#  \V   The release of Bash, version + patchlevel (e.g., 2.00.0)
#  \w   The current working directory.
#  \W   The basename of $PWD.
#  \!   The history number of this command.
#  \#   The command number of this command.
#  \$   If you are not root, inserts a "$"; if you are root, you get a "#"  (root uid = 0)
#

#  ----------------------------------------------------------------------------
#  LINKS/CREDITS
#  ----------------------------------------------------------------------------
#  See: http://misc.flogisoft.com/bash/tip_colors_and_formatting
#  See: http://ss64.com/bash/syntax-prompt.html
#  See: https://gist.github.com/bingzhangdai/dd4e283a14290c079a76c4ba17f19d69
#  See: https://github.com/dylanaraps/pure-bash-bible
#  See: https://github.com/dylanaraps/pure-sh-bible
#  See: https://stackoverflow.com/a/3467959/17403258
#  See: https://stackoverflow.com/a/41940626/17403258
#

declare -A apparix
while IFS= read -r -a line; do
    parts=(${line//,/ })
    apparix["${parts[2]}"]="${parts[1]}"
    unset parts
done < "$HOME/.apparixrc"

declare -A colors
colors=(
    ["reset"]='\[\e[0m\]'        ["red"]='\[\e[31m\]'         ["light_red"]='\[\e[91m\]'
    ["bold"]='\[\e[1m\]'         ["green"]='\[\e[32m\]'       ["light_green"]='\[\e[92m\]'
    ["blink"]='\[\e[5m\]'        ["yellow"]='\[\e[33m\]'      ["light_yellow"]='\[\e[93m\]'
    ["white"]='\[\e[97m\]'       ["blue"]='\[\e[34m\]'        ["light_blue"]='\[\e[94m\]'
    ["light_gray"]='\[\e[37m\]'  ["magenta"]='\[\e[35m\]'     ["light_magenta"]='\[\e[95m\]'
    ["dark_gray"]='\[\e[90m\]'   ["cyan"]='\[\e[36m\]'        ["light_cyan"]='\[\e[96m\]'
    ["black"]='\[\e[30m\]'       ["default"]='\[\e[39m\]'
)

declare -A prefixes
prefixes=(
    ["time"]="${colors[dark_gray]}at${colors[reset]} "
    ["git"]="${colors[dark_gray]}on${colors[reset]} "
    ["timer"]="${colors[dark_gray]}took${colors[reset]} "
    ["jobs"]="${colors[dark_gray]}jobs${colors[reset]} "
    ["pwd"]="${colors[dark_gray]}in${colors[reset]} "
)

__ps1_trap () {
    PROMPT_TIMER=${PROMPT_TIMER:-$SECONDS}
}

trap '__ps1_trap' DEBUG
PROMPT_COMMAND='PS1_EXIT_CODE=$? __ps1_prompt'
PS1_LEFT=("user_host" "time" "tty_term_histnum" "pwd")
PS1_RIGHT=("jobs" "git" "timer")

__ps1_prompt () {
    local left="" right=""

    # newline (does not appear after clear)
    echo >&2

    for fn in "${PS1_LEFT[@]}"; do
        "__ps1_$fn" out
        if [[ -n $out ]]; then
            left+="$out "
        fi
        unset out
    done

    # print left side
    PS1="$left\n${colors[dark_gray]}\\\$${colors[reset]} "

    for fn in "${PS1_RIGHT[@]}"; do
        "__ps1_$fn" out
        if [[ -n $out ]]; then
            right+="$out "
        fi
        unset out
    done

    if [[ ! -z "$right" ]]; then
        __ps1_prompt_right "$right"
    fi

    unset PROMPT_TIMER
}

__ps1_prompt_right () {
    local right="$1"

    # trim trailing spaces
    right="${right%" "}"

    # remove all formatting from $right
    shopt -s extglob
    local right_text="${right//\\\[\\e\[*([^m])m\\\]/}"
    local right_len=${#right_text}

    # determine the lenght of the horizontal padding
    local pad
    for ((i=0; i<COLUMNS-right_len; i++)); do
        pad+=" "
    done

    # print right-side, then return, then print left
    PS1="${pad}${right}\r${PS1}"
}

__fast_git_branch () {
    local head_file head dir="$PWD"
    local -n output="$1"; output=""

    while [[ -n "$dir" ]]; do
        head_file="$dir/.git/HEAD"
        if [[ -f "$dir/.git" ]]; then
            read -r head_file < "$dir/.git" \
            && head_file="$dir/${head_file#gitdir: }/HEAD"
        fi
        [[ -e "$head_file" ]] && break
        dir="${dir%/*}"
    done

    if [[ -e "$head_file" ]]; then
        read -r head < "$head_file" || return
        case "$head" in
            ref:*) output="${head#ref: refs/heads/}" ;;
            "") ;;
            # HEAD detached
            *) output="${head:0:9}" ;;
        esac
        return 0
    fi

    return 1
}

__ps1_git () {
    local -n output="$1"; output=""

    __fast_git_branch branch

    if [[ -z "${branch}" ]]; then
        return 0
    fi

    # do NOT allow shortstat to run for mor than 100ms
    # (on big projects, loading the Git index alone can take seconds!)
    local shortstat
    if ! shortstat=$(timeout 0.1 git diff --shortstat --no-color); then
        output+="${prefixes[git]}"
        output+="${colors[blue]}${branch}"
        output+="${colors[dark_gray]}:t/o"
        output+="${colors[reset]}"
        return 0
    fi

    local prev="" ins="" del=""
    for n in $shortstat; do
        [[ "${n:0:3}" == 'ins' ]] && ins="$prev"
        [[ "${n:0:3}" == 'del' ]] && del="$prev"
        prev="$n"
    done

    local color="${colors[green]}" diff=""
    if [[ ! -z "$ins" || ! -z "$del" ]]; then
        color="${colors[red]}"

        if [[ ! -z "$ins" ]]; then
            diff+="${colors[dark_gray]}/"
            diff+="${colors[green]}+${ins}"
            diff+="${colors[reset]}"
        fi

        if [[ ! -z "$ins" &&  ! -z "$del" ]]; then
            diff+="${colors[dark_gray]}/"
            diff+="${colors[reset]}"
        fi

        if [[ ! -z "$del" ]]; then
            diff+="${colors[red]}-${del}"
            diff+="${colors[reset]}"
        fi
    fi

    output+="${prefixes[git]}"
    output+="${color}${branch}"
    output+="${colors[reset]}"
    output+="${diff}"
}

__ps1_jobs () {
    local -n output="$1"; output=""
    local color jobs=()

    while read -r line; do
        IFS=" " set -- $line

        if [[ -z $3 ]]; then
            continue
        fi

        if [[ "$2" == "Running" ]]
            then color="${colors[green]}"
            else color="${colors[yellow]}"
        fi

        jobs+=( "${colors[dark_gray]}$1${color}$3${colors[reset]}" )
    done < <(jobs)

    if [[ -n "$jobs" ]]; then
        output="${prefixes[jobs]}${jobs[@]}${colors[reset]}"
    fi
}

__ps1_timer () {
    local -n output="$1"; output=""
    local time=$(($SECONDS - ${PROMPT_TIMER:-$SECONDS}))
    local code=${PS1_EXIT_CODE:-0}
    local color

    if [[ "$code" == 0 || "$code" == 130 ]]
        then color="${colors[green]}"
        else color="${colors[red]}"
    fi

    output="${prefixes[timer]}${color}${time:-0}s${colors[reset]}"
}

__ps1_pwd () {
    local -n output="$1"; output=""
    local max="0" short relative len

    # look for an apparix alias matching current directory
    for key in "${!apparix[@]}"; do
        if [[ "$PWD/" = "$key/"* ]]; then
            len="${#key}"
            if [ "$len" -gt "$max" ]; then
                short="${apparix["$key"]}"
                relative="${PWD#"$key"}"
                max="$len"
            fi
        fi
    done

    # if an alias is found, print the relative path
    if [ "$max" -gt "0" ]; then
        output+="${prefixes[pwd]}${colors[dark_gray]}${short}:"
        output+="${colors[yellow]}${relative:-"/"}"
        output+="${colors[reset]}"
        return
    fi

    # default behavior, just print the current working directory
    local pwd="\w"
    [[ "${#PWD}" -gt 40 ]] && pwd="../\\W"
    output+="${prefixes[pwd]}${colors[yellow]}${pwd}"
    output+="${colors[reset]}"
}

__ps1_time () {
    local -n output="$1"; output=""
    local time="\\@"

    time="${time@P}"
    time="${time%" PM"}"
    time="${time%" AM"}"
    time=(${time//:/ })

    # %h:i%
    output+="${prefixes[time]}"
    output+="${colors[yellow]}${time[0]}"
    output+="${colors[dark_gray]}:"
    output+="${colors[yellow]}${time[1]}"
    output+="${colors[reset]}"
}

__ps1_user_host () {
    local -n output="$1"; output=""
    local user="${PS1_USER:-\\u}"
    local host="${PS1_HOST:-\\h}"

    # %user%@%hostname%
    output+="${prefixes[user_host]}"
    output+="${colors[green]}${user@P}"
    output+="${colors[dark_gray]}@"
    output+="${colors[green]}${host@P}"
    output+="${colors[reset]}"
}

__ps1_tty_term_histnum () {
    local -n output="$1"; output=""
    local tty="${PS1_TTY:-\\l}"
    local shell="${PS1_SHELL:-\\s}"
    local histnum="\\!"

    if [[ "$tty" == "auto" ]]; then
        tty="\\l"
        tty="${tty@P}"

        if [[ "${tty:0:3}" != "tty" ]]; then
            tty=$(readlink /dev/fd/0)
            tty=${tty#/dev/}
        fi
    fi

    # #%tty%#%term%!%histnum%
    output+="${prefixes[tty_term_histnum]}"
    output+="${colors[dark_gray]}#${colors[blue]}${tty}"
    output+="${colors[dark_gray]}#${colors[blue]}${shell}"
    output+="${colors[dark_gray]}!${colors[magenta]}${histnum}"
    output+="${colors[reset]}"
}
