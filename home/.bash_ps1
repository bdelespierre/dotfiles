#!/bin/bash
#
#  An elegant, convenient PS1 written ~almost~ entirely in Bash.
#  Relies on the following commands: git, readlink, and timeout.
#
#  ----------------------------------------------------------------------------
#  USAGE
#  ----------------------------------------------------------------------------
#  $ source .bash_ps1
#

#  ----------------------------------------------------------------------------
#  CONFIGURATION VARIABLES
#  ----------------------------------------------------------------------------
#  PS1_USER        Set to force username                   (default:"\u")
#  PS1_HOST        Set to force hostname                   (default:"\h")
#  PS1_TTY         Set to force the TTY name               (default: "auto")
#  PS1_SHELL       Set to force shell                      (default:"\s")
#  PS1_SHOW_GIT    Show Git status                         (default: "true")
#  PS1_SHOW_JOBS   Show current jobs                       (default: "true")
#  PS1_SHOW_PWD    Show current directory                  (default: "true")
#  PS1_SHOW_TIME   Show current time                       (default: "true")
#  PS1_SHOW_TIMER  Show last command duration              (default: "true")
#  PS1_SHOW_TTY    Show show current shell, term, and TTY  (default: "true")
#  PS1_SHOW_USER   Show current user and hostname          (default: "true")
#

#  ----------------------------------------------------------------------------
#  SPECIAL PROMPT VARIABLE CHARACTERS
#  ----------------------------------------------------------------------------
#  \d   The date, in "Weekday Month Date" format (e.g., "Tue May 26").
#  \h   The hostname, up to the first . (e.g. deckard)
#  \H   The hostname. (e.g. deckard.SS64.com)
#  \j   The number of jobs currently managed by the shell.
#  \l   The basename of the shell's terminal device name.
#  \s   The name of the shell, the basename of $0 (the portion following the final slash).
#  \t   The time, in 24-hour HH:MM:SS format.
#  \T   The time, in 12-hour HH:MM:SS format.
#  \@   The time, in 12-hour am/pm format.
#  \u   The username of the current user.
#  \v   The version of Bash (e.g., 2.00)
#  \V   The release of Bash, version + patchlevel (e.g., 2.00.0)
#  \w   The current working directory.
#  \W   The basename of $PWD.
#  \!   The history number of this command.
#  \#   The command number of this command.
#  \$   If you are not root, inserts a "$"; if you are root, you get a "#"  (root uid = 0)
#

#  ----------------------------------------------------------------------------
#  LINKS/CREDITS
#  ----------------------------------------------------------------------------
#  See: http://misc.flogisoft.com/bash/tip_colors_and_formatting
#  See: http://ss64.com/bash/syntax-prompt.html
#  See: https://gist.github.com/bingzhangdai/dd4e283a14290c079a76c4ba17f19d69
#  See: https://github.com/dylanaraps/pure-bash-bible
#  See: https://github.com/dylanaraps/pure-sh-bible
#  See: https://stackoverflow.com/a/3467959/17403258
#  See: https://stackoverflow.com/a/41940626/17403258
#

#  ----------------------------------------------------------------------------
#  CONSTANTS
#  ----------------------------------------------------------------------------
#
declare -A colors
colors=(
    ["reset"]='\[\e[0m\]'        ["red"]='\[\e[31m\]'         ["light_red"]='\[\e[91m\]'
    ["bold"]='\[\e[1m\]'         ["green"]='\[\e[32m\]'       ["light_green"]='\[\e[92m\]'
    ["blink"]='\[\e[5m\]'        ["yellow"]='\[\e[33m\]'      ["light_yellow"]='\[\e[93m\]'
    ["white"]='\[\e[97m\]'       ["blue"]='\[\e[34m\]'        ["light_blue"]='\[\e[94m\]'
    ["light_gray"]='\[\e[37m\]'  ["magenta"]='\[\e[35m\]'     ["light_magenta"]='\[\e[95m\]'
    ["dark_gray"]='\[\e[90m\]'   ["cyan"]='\[\e[36m\]'        ["light_cyan"]='\[\e[96m\]'
    ["black"]='\[\e[30m\]'       ["default"]='\[\e[39m\]'
)

declare -A apparix
while IFS= read -r -a line; do
    parts=(${line//,/ })
    apparix["${parts[2]}"]="${parts[1]}"
    unset parts
done < "$HOME/.apparixrc"

__ps1_start_timer () {
    PROMPT_TIMER=${PROMPT_TIMER:-$SECONDS}
}

declare -A prefixes
prefixes=(
    ["git"]="${colors[dark_gray]}g:${colors[reset]}"
    ["timer"]="${colors[dark_gray]}t:${colors[reset]}"
)

trap '__ps1_start_timer' DEBUG
PROMPT_COMMAND='__ps1_prompt "$?" "$(jobs)"'

#  ----------------------------------------------------------------------------
#  FAST GIT BRANCH
#  ----------------------------------------------------------------------------
#  $1: (out) the function output
#
__fast_git_branch () {
    local head_file head dir="$PWD"
    local -n output="$1"; output=""

    while [[ -n "$dir" ]]; do
        head_file="$dir/.git/HEAD"
        if [[ -f "$dir/.git" ]]; then
            read -r head_file < "$dir/.git" && head_file="$dir/${head_file#gitdir: }/HEAD"
        fi
        [[ -e "$head_file" ]] && break
        dir="${dir%/*}"
    done

    if [[ -e "$head_file" ]]; then
        read -r head < "$head_file" || return
        case "$head" in
            ref:*) output="${head#ref: refs/heads/}" ;;
            "") ;;
            # HEAD detached
            *) output="${head:0:9}" ;;
        esac
        return 0
    fi

    return 1
}

#  ----------------------------------------------------------------------------
#  FORMAT GIT OUTPUT
#  ----------------------------------------------------------------------------
#  $1: (out) The function output
#
__ps1_git () {
    local -n output="$1"; output=""

    # Git Bash on Windows has its own PS1 function
    # (see /mingw64/share/git/completion/git-prompt.sh)
    # if  [[ "$MSYSTEM" == "MSYS" || "$MSYSTEM" == "MINGW64" ]] && declare -F __git_ps1 &>/dev/null; then
    #     git_ps1="$(__git_ps1)"
    #     branch=${git_ps1#"${git_ps1%%[![:space:]]*}"}
    #     [[ ! -z "${branch}" ]] && output="${prefixes["git"]}${colors[blue]}${branch}${colors[reset]}"
    #     return 0
    # fi

    __fast_git_branch branch

    if [[ -z "${branch}" ]]; then
        return 0
    fi

    # do NOT allow shortstat to run for mor than 100ms
    # (on big projects, loading the Git index alone can take seconds!)
    local shortstat
    if ! shortstat=$(timeout 0.1 git diff --shortstat --no-color); then
        output="${prefixes["git"]}${colors[blue]}${branch}${colors[reset]}${colors[dark_gray]}:t/o${colors[reset]}"
        return 0
    fi

    local prev="" ins="" del=""
    for n in $shortstat; do
        [[ "${n:0:3}" == 'ins' ]] && ins="$prev"
        [[ "${n:0:3}" == 'del' ]] && del="$prev"
        prev="$n"
    done

    local color="${colors[green]}" diff=""
    if [[ ! -z "$ins" || ! -z "$del" ]]; then
        color="${colors[red]}"
        [[ ! -z "$ins" ]] && diff="${colors[dark_gray]}/${colors[reset]}${colors[green]}+${ins}${colors[reset]}"
        [[ ! -z "$ins" &&  ! -z "$del" ]] && diff+="${colors[dark_gray]}/${colors[reset]}"
        [[ ! -z "$del" ]] && diff+="${colors[red]}-${del}${colors[reset]}"
    fi

    output="${prefixes["git"]}${color}${branch}${colors[reset]}${diff}"
}

#  ----------------------------------------------------------------------------
#  FORMAT JOBS OUTPUT
#  ----------------------------------------------------------------------------
#  $1: The output of 'jobs' command
#  $2: (out) The function output
#
__ps1_jobs () {
    local color
    local -n output="$2"; output=""

    while IFS="\n" read -r -a job; do
        IFS=" " set -- $job
        [[ -z $3 ]] && continue
        [[ "$2" == "Running" ]] && color="${colors[green]}" || color="${colors[yellow]}"
        [[ ! -z "$output" ]] && output+=" "
        output+="${colors[dark_gray]}$1${color}$3${colors[reset]}"
    done <<< "$1"
}

#  ----------------------------------------------------------------------------
#  FORMAT TIMER OUTPUT
#  ----------------------------------------------------------------------------
#  $1: The elapsed time since the last command (see __ps1_start_timer)
#  $2: The exit code of the last command ($?)
#  $3: (out) The function output
#
__ps1_timer () {
    local color
    local -n output="$3"; output=""
    [[ 0 == "$2" || 130 == "$2" ]] && color="${colors[green]}" || color="${colors[red]}"
    output="${prefixes["timer"]}${color}${1:-0}s${colors[reset]}"
}

#  ----------------------------------------------------------------------------
#  FORMAT PWD OUTPUT
#  ----------------------------------------------------------------------------
#  $1: (out) The function output
#
__ps1_pwd () {
    local -n output="$1"; output=""

    for key in "${!apparix[@]}"; do
        if [[ "$PWD/" = "$key/"* ]]; then
            relative="${PWD#"$key"}"
            output="${colors[dark_gray]}${apparix[$key]}:${colors[yellow]}${relative:-"/"}${colors[reset]}"
            return
        fi
    done

    local pwd="\w"
    [[ "${#PWD}" > 40 ]] && pwd="../\\W"
    output="${colors[yellow]}${pwd}${colors[reset]}"
}

#  ----------------------------------------------------------------------------
#  PROMPT
#  ----------------------------------------------------------------------------
#  $1: The result of 'jobs' command
#  $2: The exit code of the last command ($?)
#
__ps1_prompt () {
    local git_output jobs_output timer_output left=""

    # newline (does not appear after clear)
    echo >&2

    # %user%@%hostname%
    if [[ "${PS1_SHOW_USER:-true}" == "true" ]]; then
        left+="${colors[green]}${PS1_USER:-\u}${colors[dark_gray]}@${colors[green]}${PS1_HOST:-\h}${colors[reset]} "
    fi

    # %h:i:s%
    if [[ "${PS1_SHOW_TIME:-true}" == "true" ]]; then
        time="\\@"
        time="${time@P}"
        time="${time%" PM"}"
        time="${time%" AM"}"
        left+="${colors[yellow]}${time}${colors[reset]} "
    fi

    # #%tty%#%term%!%histnum%
    if [[ "$PS1_TTY" == "auto" ]]; then
        PS1_TTY="\\l"
        PS1_TTY="${PS1_TTY@P}"
        if [[ "${PS1_TTY:0:3}" != "tty" ]]; then
            PS1_TTY=$(readlink /dev/fd/0)
            PS1_TTY=${PS1_TTY#/dev/}
        fi
    fi

    if [[ "${PS1_SHOW_TTY:-true}" == "true" ]]; then
        left+="${colors[dark_gray]}#${colors[blue]}${PS1_TTY:-\\l}"
        left+="${colors[dark_gray]}#${colors[blue]}${PS1_SHELL:-\\s}"
        left+="${colors[dark_gray]}!${colors[magenta]}\\!${colors[reset]} "
    fi

    # %apparix%:%relative% or %pwd% or ../%dir%
    if [[ "${PS1_SHOW_PWD:-true}" == "true" ]]; then
        __ps1_pwd pwd_output
        left+="$pwd_output"
    fi

    # left-side built!
    PS1="$left\n${colors[dark_gray]}\\\$${colors[reset]} "

    right=""

    if [[ "${PS1_SHOW_TIMER:-true}" == "true" ]]; then
        __ps1_timer $(($SECONDS - ${PROMPT_TIMER:-$SECONDS})) "$1" timer_output
        right="$timer_output $right"
    fi

    if [[ "${PS1_SHOW_GIT:-true}" == "true" ]]; then
        __ps1_git git_output
        right="$git_output $right"
    fi

    if [[ "${PS1_SHOW_JOBS:-true}" == "true" ]]; then
        __ps1_jobs "$2" jobs_output
        right="$jobs_output $right"
    fi

    # left-side built!
    right="${right%" "}"

    if [[ -z "$right" ]]; then
        return 0
    fi

    # remove all formatting from $right
    shopt -s extglob
    local right_text="${right//\\\[\\e\[*([^m])m\\\]/}"
    local right_len=${#right_text}

    # determine the lenght of the horizontal padding
    local pad
    for ((i=0; i<COLUMNS-right_len; i++)); do
        pad+=" "
    done

    # print right-side, then return, then print left
    PS1="${pad}${right}\r${PS1}"

    unset PROMPT_TIMER
}
