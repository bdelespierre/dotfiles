#!/bin/bash
#
#  An elegant, convenient PS1 written ~almost~ entirely in Bash.
#  Relies on the following commands: git, readlink, and timeout.
#
#  ----------------------------------------------------------------------------
#  USAGE
#  ----------------------------------------------------------------------------
#
#  $ source .bash_ps1
#
#
#  ----------------------------------------------------------------------------
#  CONFIGURATION VARIABLES
#  ----------------------------------------------------------------------------
#
#  PS1_USER     Set to force username   (default:"\u")
#  PS1_HOST     Set to force hostname   (default:"\h")
#  PS1_SHELL    Set to force shell      (default:"\s")
#  PS1_TERM     Set to force term       (default:"\l")
#  PS1_RIGHT    Enable right side       (default:"true")
#  PS1_GIT      Enable git status       (default:"true")
#  PS1_JOBS     Enable jobs summary     (default:"true")
#  PS1_TIMER    Enable stopwatch        (default:"true")
#
#
#  ----------------------------------------------------------------------------
#  SPECIAL PROMPT VARIABLE CHARACTERS
#  ----------------------------------------------------------------------------
#
#  \d   The date, in "Weekday Month Date" format (e.g., "Tue May 26").
#  \h   The hostname, up to the first . (e.g. deckard)
#  \H   The hostname. (e.g. deckard.SS64.com)
#  \j   The number of jobs currently managed by the shell.
#  \l   The basename of the shell's terminal device name.
#  \s   The name of the shell, the basename of $0 (the portion following the final slash).
#  \t   The time, in 24-hour HH:MM:SS format.
#  \T   The time, in 12-hour HH:MM:SS format.
#  \@   The time, in 12-hour am/pm format.
#  \u   The username of the current user.
#  \v   The version of Bash (e.g., 2.00)
#  \V   The release of Bash, version + patchlevel (e.g., 2.00.0)
#  \w   The current working directory.
#  \W   The basename of $PWD.
#  \!   The history number of this command.
#  \#   The command number of this command.
#  \$   If you are not root, inserts a "$"; if you are root, you get a "#"  (root uid = 0)
#
#
#  ----------------------------------------------------------------------------
#  LINKS/CREDITS
#  ----------------------------------------------------------------------------
#
#  See: http://misc.flogisoft.com/bash/tip_colors_and_formatting
#  See: http://ss64.com/bash/syntax-prompt.html
#  See: https://gist.github.com/bingzhangdai/dd4e283a14290c079a76c4ba17f19d69
#  See: https://github.com/dylanaraps/pure-bash-bible
#  See: https://github.com/dylanaraps/pure-sh-bible
#  See: https://stackoverflow.com/a/3467959/17403258
#  See: https://stackoverflow.com/a/41940626/17403258
#
#
declare -A colors
colors=(
    ["reset"]='\[\e[0m\]'        ["red"]='\[\e[31m\]'         ["light_red"]='\[\e[91m\]'
    ["bold"]='\[\e[1m\]'         ["green"]='\[\e[32m\]'       ["light_green"]='\[\e[92m\]'
    ["blink"]='\[\e[5m\]'        ["yellow"]='\[\e[33m\]'      ["light_yellow"]='\[\e[93m\]'
    ["white"]='\[\e[97m\]'       ["blue"]='\[\e[34m\]'        ["light_blue"]='\[\e[94m\]'
    ["light_gray"]='\[\e[37m\]'  ["magenta"]='\[\e[35m\]'     ["light_magenta"]='\[\e[95m\]'
    ["dark_gray"]='\[\e[90m\]'   ["cyan"]='\[\e[36m\]'        ["light_cyan"]='\[\e[96m\]'
    ["black"]='\[\e[30m\]'       ["default"]='\[\e[39m\]'
)

__ps1_env_windows () {
    if [[ "$MSYSTEM" == "MSYS" || "$MSYSTEM" == "MINGW64" ]]; then
        return 0
    fi

    return 1
}

__fast_git_branch () {
    # $1: (out) the function output

    local head_file head dir="$PWD"
    local -n output="$1"; output=""

    while [[ -n "$dir" ]]; do
        head_file="$dir/.git/HEAD"
        if [[ -f "$dir/.git" ]]; then
            read -r head_file < "$dir/.git" && head_file="$dir/${head_file#gitdir: }/HEAD"
        fi
        [[ -e "$head_file" ]] && break
        dir="${dir%/*}"
    done

    if [[ -e "$head_file" ]]; then
        read -r head < "$head_file" || return
        case "$head" in
            ref:*) output="${head#ref: refs/heads/}" ;;
            "") ;;
            # HEAD detached
            *) output="${head:0:9}" ;;
        esac
        return 0
    fi

    return 1
}

__ps1_git () {
    # $1: (out) The function output

    local -n output="$1"; output=""
    local prefix="${colors[dark_gray]}git:${colors[reset]}"

    # Git Bash on Windows has its own PS1 function
    # (see /mingw64/share/git/completion/git-prompt.sh)
    if __ps1_env_windows && declare -F __git_ps1 &>/dev/null; then
        git_ps1="$(__git_ps1)"
        output="${prefix}${colors[blue]}${git_ps1#"${git_ps1%%[![:space:]]*}"}${colors[reset]}"
        return 0
    fi

    __fast_git_branch branch

    if [[ -z "${branch}" ]]; then
        return 0
    fi

    # do NOT allow shortstat to run for mor than 100ms
    # (on big projects, loading the Git index alone can take seconds!)
    local shortstat
    if ! shortstat=$(timeout 0.1 git diff --shortstat --no-color ); then
        output="${prefix}${colors[blue]}${branch}${colors[reset]}${colors[dark_gray]}:t/o${colors[reset]}"
        return 0
    fi

    local prev="" ins="" del=""
    for n in $shortstat; do
        [[ "${n:0:3}" == 'ins' ]] && ins="$prev"
        [[ "${n:0:3}" == 'del' ]] && del="$prev"
        prev="$n"
    done

    local color="${colors[green]}" diff=""
    if [[ ! -z "$ins" || ! -z "$del" ]]; then
        color="${colors[red]}"
        [[ ! -z "$ins" ]] && diff="${colors[dark_gray]}/${colors[reset]}${colors[green]}+${ins}${colors[reset]}"
        [[ ! -z "$ins" &&  ! -z "$del" ]] && diff+="${colors[dark_gray]}/${colors[reset]}"
        [[ ! -z "$del" ]] && diff+="${colors[red]}-${del}${colors[reset]}"
    fi

    output="${prefix}${color}${branch}${colors[reset]}${diff}"
}

__ps1_jobs () {
    # $1: The output of 'jobs' command
    # $2: (out) The function output

    local color
    local -n output="$2"; output=""

    while IFS="\n" read -r -a job; do
        IFS=" " set -- $job
        [[ -z $3 ]] && continue
        [[ "$2" == "Running" ]] && color="${colors[green]}" || color="${colors[yellow]}"
        [[ ! -z "$output" ]] && output+=" "
        output+="${colors[dark_gray]}$1${color}$3${colors[reset]}"
    done <<< "$1"
}

__ps1_timer () {
    # $1: The elapsed time since the last command (see __ps1_start_timer)
    # $2: The exit code of the last command ($?)
    # $3: (out) The function output

    local color
    local -n output="$3"; output=""
    [[ 0 == "$2" || 130 == "$2" ]] && color="${colors[green]}" || color="${colors[red]}"
    output="${colors[dark_gray]}time:${color}${1:-0}s${colors[reset]}"
}

__remove_escape () {
    # $1: The string to clean
    # $2: (out) The function output

    local -n output="$2"; output=""
    local str="$1"
    declare local max=100
}

__ps1_prompt () {
    # $1: The result of 'jobs' command
    # $2: The exit code of the last command ($?)

    local git_output jobs_output timer_output

    # newline (does not appear after clear)
    echo >&2

    # %user%@%hostname%
    local left="${colors[green]}${PS1_USER:-\u}${colors[dark_gray]}@${colors[green]}${PS1_HOST:-\h}${colors[reset]} "

    # %h:i:s%
    left+="${colors[yellow]}\\t${colors[reset]} "

    # #%tty%#%term%!%histnum%
    if [[ "$PS1_TTY" == "auto" ]]; then
        PS1_TTY="\\l"
        PS1_TTY="${PS1_TTY@P}"
        if [[ "${PS1_TTY:0:3}" != "tty" ]]; then
            PS1_TTY=$(readlink /dev/fd/0)
            PS1_TTY=${PS1_TTY#/dev/}
        fi
    fi

    left+="${colors[dark_gray]}#${colors[blue]}${PS1_TTY:-\\l}"
    left+="${colors[dark_gray]}#${colors[blue]}${PS1_SHELL:-\\s}"
    left+="${colors[dark_gray]}!${colors[magenta]}\\!${colors[reset]} "

    # %pwd% or ../%dir%
    local pwd="\w"
    [[ "${#PWD}" > 40 ]] && pwd="../\\W"
    left+="${colors[yellow]}${pwd}${colors[reset]}"

    # left-side built!
    PS1="$left\n${colors[dark_gray]}\\\$${colors[reset]} "

    if [[ "${PS1_RIGHT:-true}" == "false" || "${PS1_GIT}${PS1_JOBS}${PS1_TIMER}" == "falsefalsefalse" ]]; then
        return 0
    fi

    [[ "${PS1_GIT:-true}" == "true" ]] && __ps1_git git_output
    [[ "${PS1_JOBS:-true}" == "true" ]] && __ps1_jobs "$2" jobs_output
    [[ "${PS1_TIMER:-true}" == "true" ]] && __ps1_timer $(($SECONDS - ${PROMPT_TIMER:-$SECONDS})) "$1" timer_output

    local right="$timer_output"
    [[ ! -z "$jobs_output" ]] && right="$jobs_output $right"
    [[ ! -z "$git_output" ]] && right="$git_output $right"

    # remove all formatting from $right
    shopt -s extglob
    local right_text="${right//\\\[\\e\[*([^m])m\\\]/}"
    local right_len=${#right_text}

    # determine the lenght of the horizontal padding
    local pad
    for ((i=0; i<COLUMNS-right_len; i++)); do
        pad+=" "
    done

    # print right-side, then return, then print left
    PS1="${pad}${right}\r${PS1}"

    unset PROMPT_TIMER
}

__ps1_start_timer () {
    PROMPT_TIMER=${PROMPT_TIMER:-$SECONDS}
}

trap '__ps1_start_timer' DEBUG
PROMPT_COMMAND='__ps1_prompt "$?" "$(jobs)"'
